/**
 * Softomate Person API
 * This is a API for Softomate testwork
 *
 * OpenAPI spec version: 1.0.0
 * Contact: imail.for.iwork@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 *
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import {Inject, Injectable, Optional} from '@angular/core';
import {Http, Headers, URLSearchParams} from '@angular/http';
import {RequestMethod, RequestOptions, RequestOptionsArgs} from '@angular/http';
import {Response, ResponseContentType} from '@angular/http';

import {Observable} from 'rxjs/Observable';
import '../rxjs-operators';

import { ErrorMessage } from '../model/errorMessage';
import { Person } from '../model/person';

import { COLLECTION_FORMATS } from '../variables';
import {Configuration} from '../configuration';

import {environment} from '../../../../../environments/environment';


@Injectable()
export class PersonsService {

    // protected basePath = 'https://virtserver.swaggerhub.com/iworksrc/softomate/1.0.0';
    protected TAG = 'Persons';
    protected basePath = environment.BASE_PATH;

    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }

    /**
     *
     */
    public getBasePath(): string {
        return this.basePath;
    }

    /**
     *
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    private extendObj<T1, T2>(objA: T1, objB: T2) {
        for (const key in objB) {
            if (objB.hasOwnProperty(key)) {
                (objA as any)[key] = (objB as any)[key];
            }
        }
        return <T1&T2>objA;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    /**
     * create new Person
     * @summary create Person
     * @param person
     */
    public createNewPerson(person: Person, extraHttpRequestParams?: any): Observable<{}> {
        return this.createNewPersonWithHttpInfo(person, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * get all person in system
     * @summary get all persons
     */
    public getAllPersons(extraHttpRequestParams?: any): Observable<Array<Person>> {
        return this.getAllPersonsWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * get Person by id if exists or null otherwise
     * @summary get person by id
     * @param id
     */
    public getPersonById(id: string, extraHttpRequestParams?: any): Observable<Person> {
        return this.getPersonByIdWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * create Person
     * create new Person
     * @param person
     */
    public createNewPersonWithHttpInfo(person: Person, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/person';

        const queryParameters = new URLSearchParams();
        const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'person' is not null or undefined
        if (person === null || person === undefined) {
            throw new Error('Required parameter person was null or undefined when calling createNewPerson.');
        }

        // to determine the Accept header
        const produces: string[] = [
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: person == null ? '' : JSON.stringify(person), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * get all persons
     * get all person in system
     */
    public getAllPersonsWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/person';

        const queryParameters = new URLSearchParams();
        const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        const produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * get person by id
     * get Person by id if exists or null otherwise
     * @param id
     */
    public getPersonByIdWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/person/${id}'
                    .replace('${' + 'id' + '}', String(id));

        const queryParameters = new URLSearchParams();
        const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPersonById.');
        }

        // to determine the Accept header
        const produces: string[] = [
            'application/json',
            'application/xhtml+xml'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete an Person
     * @summary delete an Person
     * @param id
     */
    public deletePerson(id: string, extraHttpRequestParams?: any): Observable<{}> {
      return this.deletePersonWithHttpInfo(id, extraHttpRequestParams)
        .map((response: Response) => {
          if (response.status === 204) {
            return undefined;
          } else {
            return response.json() || {};
          }
        });
    }

    /**
     * delete an Person
     * delete an Person
     * @param id
     */
    public deletePersonWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
      const path = this.basePath + '/person/${id}'
        .replace('${' + 'id' + '}', String(id));

      const queryParameters = new URLSearchParams();
      const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new Error('Required parameter id was null or undefined when calling deletePerson.');
      }

      // to determine the Accept header
      const produces: string[] = [
      ];


      let requestOptions: RequestOptionsArgs = new RequestOptions({
        method: RequestMethod.Delete,
        headers: headers,
        search: queryParameters,
        withCredentials: this.configuration.withCredentials
      });
      // https://github.com/swagger-api/swagger-codegen/issues/4037
      if (extraHttpRequestParams) {
        requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }

      return this.http.request(path, requestOptions);
    }

    /**
     * update an Person record
     * @summary update an Person record
     * @param person
     */
    public updatePerson(person: Person, extraHttpRequestParams?: any): Observable<{}> {
      return this.updatePersonWithHttpInfo(person, extraHttpRequestParams)
        .map((response: Response) => {
          if (response.status === 204) {
            return undefined;
          } else {
            return response.json() || {};
          }
        });
    }

    /**
     * update an Person record
     * update an Person record
     * @param person
     */
    public updatePersonWithHttpInfo(person: Person, extraHttpRequestParams?: any): Observable<Response> {
      const path = this.basePath + '/person';

      const queryParameters = new URLSearchParams();
      const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

      // verify required parameter 'person' is not null or undefined
      if (person === null || person === undefined) {
        throw new Error('Required parameter person was null or undefined when calling updatePerson.');
      }

      // to determine the Accept header
      const produces: string[] = [
      ];


      headers.set('Content-Type', 'application/json');

      let requestOptions: RequestOptionsArgs = new RequestOptions({
        method: RequestMethod.Put,
        headers: headers,
        body: person == null ? '' : JSON.stringify(person), // https://github.com/angular/angular/issues/10612
        search: queryParameters,
        withCredentials: this.configuration.withCredentials
      });
      // https://github.com/swagger-api/swagger-codegen/issues/4037
      if (extraHttpRequestParams) {
        requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
      }

      return this.http.request(path, requestOptions);
    }


}
